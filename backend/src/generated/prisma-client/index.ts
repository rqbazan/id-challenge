// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from 'graphql'
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from 'prisma-client-lib'
import { typeDefs } from './prisma-schema'

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U]

export type Maybe<T> = T | undefined | null

export interface Exists {
  category: (where?: CategoryWhereInput) => Promise<boolean>
  chat: (where?: ChatWhereInput) => Promise<boolean>
  groupChat: (where?: GroupChatWhereInput) => Promise<boolean>
  message: (where?: MessageWhereInput) => Promise<boolean>
  privateChat: (where?: PrivateChatWhereInput) => Promise<boolean>
  user: (where?: UserWhereInput) => Promise<boolean>
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>
}

export interface Prisma {
  $exists: Exists
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>

  /**
   * Queries
   */

  category: (where: CategoryWhereUniqueInput) => CategoryNullablePromise
  categories: (args?: {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => FragmentableArray<Category>
  categoriesConnection: (args?: {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => CategoryConnectionPromise
  chat: (where: ChatWhereUniqueInput) => ChatNullablePromise
  chats: (args?: {
    where?: ChatWhereInput
    orderBy?: ChatOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => FragmentableArray<Chat>
  chatsConnection: (args?: {
    where?: ChatWhereInput
    orderBy?: ChatOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => ChatConnectionPromise
  groupChat: (where: GroupChatWhereUniqueInput) => GroupChatNullablePromise
  groupChats: (args?: {
    where?: GroupChatWhereInput
    orderBy?: GroupChatOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => FragmentableArray<GroupChat>
  groupChatsConnection: (args?: {
    where?: GroupChatWhereInput
    orderBy?: GroupChatOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => GroupChatConnectionPromise
  message: (where: MessageWhereUniqueInput) => MessageNullablePromise
  messages: (args?: {
    where?: MessageWhereInput
    orderBy?: MessageOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => FragmentableArray<Message>
  messagesConnection: (args?: {
    where?: MessageWhereInput
    orderBy?: MessageOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => MessageConnectionPromise
  privateChat: (
    where: PrivateChatWhereUniqueInput
  ) => PrivateChatNullablePromise
  privateChats: (args?: {
    where?: PrivateChatWhereInput
    orderBy?: PrivateChatOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => FragmentableArray<PrivateChat>
  privateChatsConnection: (args?: {
    where?: PrivateChatWhereInput
    orderBy?: PrivateChatOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => PrivateChatConnectionPromise
  user: (where: UserWhereUniqueInput) => UserNullablePromise
  users: (args?: {
    where?: UserWhereInput
    orderBy?: UserOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => FragmentableArray<User>
  usersConnection: (args?: {
    where?: UserWhereInput
    orderBy?: UserOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => UserConnectionPromise
  node: (args: { id: ID_Output }) => Node

  /**
   * Mutations
   */

  createCategory: (data: CategoryCreateInput) => CategoryPromise
  updateCategory: (args: {
    data: CategoryUpdateInput
    where: CategoryWhereUniqueInput
  }) => CategoryPromise
  updateManyCategories: (args: {
    data: CategoryUpdateManyMutationInput
    where?: CategoryWhereInput
  }) => BatchPayloadPromise
  upsertCategory: (args: {
    where: CategoryWhereUniqueInput
    create: CategoryCreateInput
    update: CategoryUpdateInput
  }) => CategoryPromise
  deleteCategory: (where: CategoryWhereUniqueInput) => CategoryPromise
  deleteManyCategories: (where?: CategoryWhereInput) => BatchPayloadPromise
  createChat: (data: ChatCreateInput) => ChatPromise
  updateChat: (args: {
    data: ChatUpdateInput
    where: ChatWhereUniqueInput
  }) => ChatPromise
  updateManyChats: (args: {
    data: ChatUpdateManyMutationInput
    where?: ChatWhereInput
  }) => BatchPayloadPromise
  upsertChat: (args: {
    where: ChatWhereUniqueInput
    create: ChatCreateInput
    update: ChatUpdateInput
  }) => ChatPromise
  deleteChat: (where: ChatWhereUniqueInput) => ChatPromise
  deleteManyChats: (where?: ChatWhereInput) => BatchPayloadPromise
  createGroupChat: (data: GroupChatCreateInput) => GroupChatPromise
  updateGroupChat: (args: {
    data: GroupChatUpdateInput
    where: GroupChatWhereUniqueInput
  }) => GroupChatPromise
  upsertGroupChat: (args: {
    where: GroupChatWhereUniqueInput
    create: GroupChatCreateInput
    update: GroupChatUpdateInput
  }) => GroupChatPromise
  deleteGroupChat: (where: GroupChatWhereUniqueInput) => GroupChatPromise
  deleteManyGroupChats: (where?: GroupChatWhereInput) => BatchPayloadPromise
  createMessage: (data: MessageCreateInput) => MessagePromise
  updateMessage: (args: {
    data: MessageUpdateInput
    where: MessageWhereUniqueInput
  }) => MessagePromise
  updateManyMessages: (args: {
    data: MessageUpdateManyMutationInput
    where?: MessageWhereInput
  }) => BatchPayloadPromise
  upsertMessage: (args: {
    where: MessageWhereUniqueInput
    create: MessageCreateInput
    update: MessageUpdateInput
  }) => MessagePromise
  deleteMessage: (where: MessageWhereUniqueInput) => MessagePromise
  deleteManyMessages: (where?: MessageWhereInput) => BatchPayloadPromise
  createPrivateChat: (data: PrivateChatCreateInput) => PrivateChatPromise
  updatePrivateChat: (args: {
    data: PrivateChatUpdateInput
    where: PrivateChatWhereUniqueInput
  }) => PrivateChatPromise
  upsertPrivateChat: (args: {
    where: PrivateChatWhereUniqueInput
    create: PrivateChatCreateInput
    update: PrivateChatUpdateInput
  }) => PrivateChatPromise
  deletePrivateChat: (where: PrivateChatWhereUniqueInput) => PrivateChatPromise
  deleteManyPrivateChats: (where?: PrivateChatWhereInput) => BatchPayloadPromise
  createUser: (data: UserCreateInput) => UserPromise
  updateUser: (args: {
    data: UserUpdateInput
    where: UserWhereUniqueInput
  }) => UserPromise
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput
    where?: UserWhereInput
  }) => BatchPayloadPromise
  upsertUser: (args: {
    where: UserWhereUniqueInput
    create: UserCreateInput
    update: UserUpdateInput
  }) => UserPromise
  deleteUser: (where: UserWhereUniqueInput) => UserPromise
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise

  /**
   * Subscriptions
   */

  $subscribe: Subscription
}

export interface Subscription {
  category: (
    where?: CategorySubscriptionWhereInput
  ) => CategorySubscriptionPayloadSubscription
  chat: (
    where?: ChatSubscriptionWhereInput
  ) => ChatSubscriptionPayloadSubscription
  groupChat: (
    where?: GroupChatSubscriptionWhereInput
  ) => GroupChatSubscriptionPayloadSubscription
  message: (
    where?: MessageSubscriptionWhereInput
  ) => MessageSubscriptionPayloadSubscription
  privateChat: (
    where?: PrivateChatSubscriptionWhereInput
  ) => PrivateChatSubscriptionPayloadSubscription
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T
}

/**
 * Types
 */

export type CategoryOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'name_ASC'
  | 'name_DESC'

export type ChatType = 'PRIVATE' | 'GROUP'

export type ChatOrderByInput = 'id_ASC' | 'id_DESC' | 'type_ASC' | 'type_DESC'

export type UserOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'nickname_ASC'
  | 'nickname_DESC'

export type MessageOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'content_ASC'
  | 'content_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'

export type GroupChatOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'

export type PrivateChatOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'

export type MutationType = 'CREATED' | 'UPDATED' | 'DELETED'

export type CategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>
  name?: Maybe<String>
}>

export interface CategoryWhereInput {
  id?: Maybe<ID_Input>
  id_not?: Maybe<ID_Input>
  id_in?: Maybe<ID_Input[] | ID_Input>
  id_not_in?: Maybe<ID_Input[] | ID_Input>
  id_lt?: Maybe<ID_Input>
  id_lte?: Maybe<ID_Input>
  id_gt?: Maybe<ID_Input>
  id_gte?: Maybe<ID_Input>
  id_contains?: Maybe<ID_Input>
  id_not_contains?: Maybe<ID_Input>
  id_starts_with?: Maybe<ID_Input>
  id_not_starts_with?: Maybe<ID_Input>
  id_ends_with?: Maybe<ID_Input>
  id_not_ends_with?: Maybe<ID_Input>
  name?: Maybe<String>
  name_not?: Maybe<String>
  name_in?: Maybe<String[] | String>
  name_not_in?: Maybe<String[] | String>
  name_lt?: Maybe<String>
  name_lte?: Maybe<String>
  name_gt?: Maybe<String>
  name_gte?: Maybe<String>
  name_contains?: Maybe<String>
  name_not_contains?: Maybe<String>
  name_starts_with?: Maybe<String>
  name_not_starts_with?: Maybe<String>
  name_ends_with?: Maybe<String>
  name_not_ends_with?: Maybe<String>
  AND?: Maybe<CategoryWhereInput[] | CategoryWhereInput>
  OR?: Maybe<CategoryWhereInput[] | CategoryWhereInput>
  NOT?: Maybe<CategoryWhereInput[] | CategoryWhereInput>
}

export type ChatWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>
}>

export interface ChatWhereInput {
  id?: Maybe<ID_Input>
  id_not?: Maybe<ID_Input>
  id_in?: Maybe<ID_Input[] | ID_Input>
  id_not_in?: Maybe<ID_Input[] | ID_Input>
  id_lt?: Maybe<ID_Input>
  id_lte?: Maybe<ID_Input>
  id_gt?: Maybe<ID_Input>
  id_gte?: Maybe<ID_Input>
  id_contains?: Maybe<ID_Input>
  id_not_contains?: Maybe<ID_Input>
  id_starts_with?: Maybe<ID_Input>
  id_not_starts_with?: Maybe<ID_Input>
  id_ends_with?: Maybe<ID_Input>
  id_not_ends_with?: Maybe<ID_Input>
  type?: Maybe<ChatType>
  type_not?: Maybe<ChatType>
  type_in?: Maybe<ChatType[] | ChatType>
  type_not_in?: Maybe<ChatType[] | ChatType>
  AND?: Maybe<ChatWhereInput[] | ChatWhereInput>
  OR?: Maybe<ChatWhereInput[] | ChatWhereInput>
  NOT?: Maybe<ChatWhereInput[] | ChatWhereInput>
}

export type GroupChatWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>
}>

export interface UserWhereInput {
  id?: Maybe<ID_Input>
  id_not?: Maybe<ID_Input>
  id_in?: Maybe<ID_Input[] | ID_Input>
  id_not_in?: Maybe<ID_Input[] | ID_Input>
  id_lt?: Maybe<ID_Input>
  id_lte?: Maybe<ID_Input>
  id_gt?: Maybe<ID_Input>
  id_gte?: Maybe<ID_Input>
  id_contains?: Maybe<ID_Input>
  id_not_contains?: Maybe<ID_Input>
  id_starts_with?: Maybe<ID_Input>
  id_not_starts_with?: Maybe<ID_Input>
  id_ends_with?: Maybe<ID_Input>
  id_not_ends_with?: Maybe<ID_Input>
  nickname?: Maybe<String>
  nickname_not?: Maybe<String>
  nickname_in?: Maybe<String[] | String>
  nickname_not_in?: Maybe<String[] | String>
  nickname_lt?: Maybe<String>
  nickname_lte?: Maybe<String>
  nickname_gt?: Maybe<String>
  nickname_gte?: Maybe<String>
  nickname_contains?: Maybe<String>
  nickname_not_contains?: Maybe<String>
  nickname_starts_with?: Maybe<String>
  nickname_not_starts_with?: Maybe<String>
  nickname_ends_with?: Maybe<String>
  nickname_not_ends_with?: Maybe<String>
  AND?: Maybe<UserWhereInput[] | UserWhereInput>
  OR?: Maybe<UserWhereInput[] | UserWhereInput>
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>
}

export interface MessageWhereInput {
  id?: Maybe<ID_Input>
  id_not?: Maybe<ID_Input>
  id_in?: Maybe<ID_Input[] | ID_Input>
  id_not_in?: Maybe<ID_Input[] | ID_Input>
  id_lt?: Maybe<ID_Input>
  id_lte?: Maybe<ID_Input>
  id_gt?: Maybe<ID_Input>
  id_gte?: Maybe<ID_Input>
  id_contains?: Maybe<ID_Input>
  id_not_contains?: Maybe<ID_Input>
  id_starts_with?: Maybe<ID_Input>
  id_not_starts_with?: Maybe<ID_Input>
  id_ends_with?: Maybe<ID_Input>
  id_not_ends_with?: Maybe<ID_Input>
  content?: Maybe<String>
  content_not?: Maybe<String>
  content_in?: Maybe<String[] | String>
  content_not_in?: Maybe<String[] | String>
  content_lt?: Maybe<String>
  content_lte?: Maybe<String>
  content_gt?: Maybe<String>
  content_gte?: Maybe<String>
  content_contains?: Maybe<String>
  content_not_contains?: Maybe<String>
  content_starts_with?: Maybe<String>
  content_not_starts_with?: Maybe<String>
  content_ends_with?: Maybe<String>
  content_not_ends_with?: Maybe<String>
  createdAt?: Maybe<DateTimeInput>
  createdAt_not?: Maybe<DateTimeInput>
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
  createdAt_lt?: Maybe<DateTimeInput>
  createdAt_lte?: Maybe<DateTimeInput>
  createdAt_gt?: Maybe<DateTimeInput>
  createdAt_gte?: Maybe<DateTimeInput>
  author?: Maybe<UserWhereInput>
  chat?: Maybe<ChatWhereInput>
  AND?: Maybe<MessageWhereInput[] | MessageWhereInput>
  OR?: Maybe<MessageWhereInput[] | MessageWhereInput>
  NOT?: Maybe<MessageWhereInput[] | MessageWhereInput>
}

export interface GroupChatWhereInput {
  id?: Maybe<ID_Input>
  id_not?: Maybe<ID_Input>
  id_in?: Maybe<ID_Input[] | ID_Input>
  id_not_in?: Maybe<ID_Input[] | ID_Input>
  id_lt?: Maybe<ID_Input>
  id_lte?: Maybe<ID_Input>
  id_gt?: Maybe<ID_Input>
  id_gte?: Maybe<ID_Input>
  id_contains?: Maybe<ID_Input>
  id_not_contains?: Maybe<ID_Input>
  id_starts_with?: Maybe<ID_Input>
  id_not_starts_with?: Maybe<ID_Input>
  id_ends_with?: Maybe<ID_Input>
  id_not_ends_with?: Maybe<ID_Input>
  category?: Maybe<CategoryWhereInput>
  participates_every?: Maybe<UserWhereInput>
  participates_some?: Maybe<UserWhereInput>
  participates_none?: Maybe<UserWhereInput>
  messages_every?: Maybe<MessageWhereInput>
  messages_some?: Maybe<MessageWhereInput>
  messages_none?: Maybe<MessageWhereInput>
  createdAt?: Maybe<DateTimeInput>
  createdAt_not?: Maybe<DateTimeInput>
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
  createdAt_lt?: Maybe<DateTimeInput>
  createdAt_lte?: Maybe<DateTimeInput>
  createdAt_gt?: Maybe<DateTimeInput>
  createdAt_gte?: Maybe<DateTimeInput>
  AND?: Maybe<GroupChatWhereInput[] | GroupChatWhereInput>
  OR?: Maybe<GroupChatWhereInput[] | GroupChatWhereInput>
  NOT?: Maybe<GroupChatWhereInput[] | GroupChatWhereInput>
}

export type MessageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>
}>

export type PrivateChatWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>
}>

export interface PrivateChatWhereInput {
  id?: Maybe<ID_Input>
  id_not?: Maybe<ID_Input>
  id_in?: Maybe<ID_Input[] | ID_Input>
  id_not_in?: Maybe<ID_Input[] | ID_Input>
  id_lt?: Maybe<ID_Input>
  id_lte?: Maybe<ID_Input>
  id_gt?: Maybe<ID_Input>
  id_gte?: Maybe<ID_Input>
  id_contains?: Maybe<ID_Input>
  id_not_contains?: Maybe<ID_Input>
  id_starts_with?: Maybe<ID_Input>
  id_not_starts_with?: Maybe<ID_Input>
  id_ends_with?: Maybe<ID_Input>
  id_not_ends_with?: Maybe<ID_Input>
  participateA?: Maybe<UserWhereInput>
  participateB?: Maybe<UserWhereInput>
  messages_every?: Maybe<MessageWhereInput>
  messages_some?: Maybe<MessageWhereInput>
  messages_none?: Maybe<MessageWhereInput>
  createdAt?: Maybe<DateTimeInput>
  createdAt_not?: Maybe<DateTimeInput>
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
  createdAt_lt?: Maybe<DateTimeInput>
  createdAt_lte?: Maybe<DateTimeInput>
  createdAt_gt?: Maybe<DateTimeInput>
  createdAt_gte?: Maybe<DateTimeInput>
  AND?: Maybe<PrivateChatWhereInput[] | PrivateChatWhereInput>
  OR?: Maybe<PrivateChatWhereInput[] | PrivateChatWhereInput>
  NOT?: Maybe<PrivateChatWhereInput[] | PrivateChatWhereInput>
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>
  nickname?: Maybe<String>
}>

export interface CategoryCreateInput {
  id?: Maybe<ID_Input>
  name: String
}

export interface CategoryUpdateInput {
  name?: Maybe<String>
}

export interface CategoryUpdateManyMutationInput {
  name?: Maybe<String>
}

export interface ChatCreateInput {
  id?: Maybe<ID_Input>
  type?: Maybe<ChatType>
}

export interface ChatUpdateInput {
  type?: Maybe<ChatType>
}

export interface ChatUpdateManyMutationInput {
  type?: Maybe<ChatType>
}

export interface GroupChatCreateInput {
  id?: Maybe<ID_Input>
  category: CategoryCreateOneInput
  participates?: Maybe<UserCreateManyInput>
  messages?: Maybe<MessageCreateManyInput>
}

export interface CategoryCreateOneInput {
  create?: Maybe<CategoryCreateInput>
  connect?: Maybe<CategoryWhereUniqueInput>
}

export interface UserCreateManyInput {
  create?: Maybe<UserCreateInput[] | UserCreateInput>
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>
  nickname: String
}

export interface MessageCreateManyInput {
  create?: Maybe<MessageCreateInput[] | MessageCreateInput>
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>
}

export interface MessageCreateInput {
  id?: Maybe<ID_Input>
  content: String
  author: UserCreateOneInput
  chat: ChatCreateOneInput
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>
  connect?: Maybe<UserWhereUniqueInput>
}

export interface ChatCreateOneInput {
  create?: Maybe<ChatCreateInput>
  connect?: Maybe<ChatWhereUniqueInput>
}

export interface GroupChatUpdateInput {
  category?: Maybe<CategoryUpdateOneRequiredInput>
  participates?: Maybe<UserUpdateManyInput>
  messages?: Maybe<MessageUpdateManyInput>
}

export interface CategoryUpdateOneRequiredInput {
  create?: Maybe<CategoryCreateInput>
  update?: Maybe<CategoryUpdateDataInput>
  upsert?: Maybe<CategoryUpsertNestedInput>
  connect?: Maybe<CategoryWhereUniqueInput>
}

export interface CategoryUpdateDataInput {
  name?: Maybe<String>
}

export interface CategoryUpsertNestedInput {
  update: CategoryUpdateDataInput
  create: CategoryCreateInput
}

export interface UserUpdateManyInput {
  create?: Maybe<UserCreateInput[] | UserCreateInput>
  update?: Maybe<
    | UserUpdateWithWhereUniqueNestedInput[]
    | UserUpdateWithWhereUniqueNestedInput
  >
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueNestedInput[]
    | UserUpsertWithWhereUniqueNestedInput
  >
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >
}

export interface UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput
  data: UserUpdateDataInput
}

export interface UserUpdateDataInput {
  nickname?: Maybe<String>
}

export interface UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput
  update: UserUpdateDataInput
  create: UserCreateInput
}

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>
  id_not?: Maybe<ID_Input>
  id_in?: Maybe<ID_Input[] | ID_Input>
  id_not_in?: Maybe<ID_Input[] | ID_Input>
  id_lt?: Maybe<ID_Input>
  id_lte?: Maybe<ID_Input>
  id_gt?: Maybe<ID_Input>
  id_gte?: Maybe<ID_Input>
  id_contains?: Maybe<ID_Input>
  id_not_contains?: Maybe<ID_Input>
  id_starts_with?: Maybe<ID_Input>
  id_not_starts_with?: Maybe<ID_Input>
  id_ends_with?: Maybe<ID_Input>
  id_not_ends_with?: Maybe<ID_Input>
  nickname?: Maybe<String>
  nickname_not?: Maybe<String>
  nickname_in?: Maybe<String[] | String>
  nickname_not_in?: Maybe<String[] | String>
  nickname_lt?: Maybe<String>
  nickname_lte?: Maybe<String>
  nickname_gt?: Maybe<String>
  nickname_gte?: Maybe<String>
  nickname_contains?: Maybe<String>
  nickname_not_contains?: Maybe<String>
  nickname_starts_with?: Maybe<String>
  nickname_not_starts_with?: Maybe<String>
  nickname_ends_with?: Maybe<String>
  nickname_not_ends_with?: Maybe<String>
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput
  data: UserUpdateManyDataInput
}

export interface UserUpdateManyDataInput {
  nickname?: Maybe<String>
}

export interface MessageUpdateManyInput {
  create?: Maybe<MessageCreateInput[] | MessageCreateInput>
  update?: Maybe<
    | MessageUpdateWithWhereUniqueNestedInput[]
    | MessageUpdateWithWhereUniqueNestedInput
  >
  upsert?: Maybe<
    | MessageUpsertWithWhereUniqueNestedInput[]
    | MessageUpsertWithWhereUniqueNestedInput
  >
  delete?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>
  set?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>
  disconnect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>
  deleteMany?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>
  updateMany?: Maybe<
    | MessageUpdateManyWithWhereNestedInput[]
    | MessageUpdateManyWithWhereNestedInput
  >
}

export interface MessageUpdateWithWhereUniqueNestedInput {
  where: MessageWhereUniqueInput
  data: MessageUpdateDataInput
}

export interface MessageUpdateDataInput {
  content?: Maybe<String>
  author?: Maybe<UserUpdateOneRequiredInput>
  chat?: Maybe<ChatUpdateOneRequiredInput>
}

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>
  update?: Maybe<UserUpdateDataInput>
  upsert?: Maybe<UserUpsertNestedInput>
  connect?: Maybe<UserWhereUniqueInput>
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput
  create: UserCreateInput
}

export interface ChatUpdateOneRequiredInput {
  create?: Maybe<ChatCreateInput>
  update?: Maybe<ChatUpdateDataInput>
  upsert?: Maybe<ChatUpsertNestedInput>
  connect?: Maybe<ChatWhereUniqueInput>
}

export interface ChatUpdateDataInput {
  type?: Maybe<ChatType>
}

export interface ChatUpsertNestedInput {
  update: ChatUpdateDataInput
  create: ChatCreateInput
}

export interface MessageUpsertWithWhereUniqueNestedInput {
  where: MessageWhereUniqueInput
  update: MessageUpdateDataInput
  create: MessageCreateInput
}

export interface MessageScalarWhereInput {
  id?: Maybe<ID_Input>
  id_not?: Maybe<ID_Input>
  id_in?: Maybe<ID_Input[] | ID_Input>
  id_not_in?: Maybe<ID_Input[] | ID_Input>
  id_lt?: Maybe<ID_Input>
  id_lte?: Maybe<ID_Input>
  id_gt?: Maybe<ID_Input>
  id_gte?: Maybe<ID_Input>
  id_contains?: Maybe<ID_Input>
  id_not_contains?: Maybe<ID_Input>
  id_starts_with?: Maybe<ID_Input>
  id_not_starts_with?: Maybe<ID_Input>
  id_ends_with?: Maybe<ID_Input>
  id_not_ends_with?: Maybe<ID_Input>
  content?: Maybe<String>
  content_not?: Maybe<String>
  content_in?: Maybe<String[] | String>
  content_not_in?: Maybe<String[] | String>
  content_lt?: Maybe<String>
  content_lte?: Maybe<String>
  content_gt?: Maybe<String>
  content_gte?: Maybe<String>
  content_contains?: Maybe<String>
  content_not_contains?: Maybe<String>
  content_starts_with?: Maybe<String>
  content_not_starts_with?: Maybe<String>
  content_ends_with?: Maybe<String>
  content_not_ends_with?: Maybe<String>
  createdAt?: Maybe<DateTimeInput>
  createdAt_not?: Maybe<DateTimeInput>
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
  createdAt_lt?: Maybe<DateTimeInput>
  createdAt_lte?: Maybe<DateTimeInput>
  createdAt_gt?: Maybe<DateTimeInput>
  createdAt_gte?: Maybe<DateTimeInput>
  AND?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>
  OR?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>
  NOT?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>
}

export interface MessageUpdateManyWithWhereNestedInput {
  where: MessageScalarWhereInput
  data: MessageUpdateManyDataInput
}

export interface MessageUpdateManyDataInput {
  content?: Maybe<String>
}

export interface MessageUpdateInput {
  content?: Maybe<String>
  author?: Maybe<UserUpdateOneRequiredInput>
  chat?: Maybe<ChatUpdateOneRequiredInput>
}

export interface MessageUpdateManyMutationInput {
  content?: Maybe<String>
}

export interface PrivateChatCreateInput {
  id?: Maybe<ID_Input>
  participateA: UserCreateOneInput
  participateB: UserCreateOneInput
  messages?: Maybe<MessageCreateManyInput>
}

export interface PrivateChatUpdateInput {
  participateA?: Maybe<UserUpdateOneRequiredInput>
  participateB?: Maybe<UserUpdateOneRequiredInput>
  messages?: Maybe<MessageUpdateManyInput>
}

export interface UserUpdateInput {
  nickname?: Maybe<String>
}

export interface UserUpdateManyMutationInput {
  nickname?: Maybe<String>
}

export interface CategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>
  updatedFields_contains?: Maybe<String>
  updatedFields_contains_every?: Maybe<String[] | String>
  updatedFields_contains_some?: Maybe<String[] | String>
  node?: Maybe<CategoryWhereInput>
  AND?: Maybe<CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput>
  OR?: Maybe<CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput>
  NOT?: Maybe<CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput>
}

export interface ChatSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>
  updatedFields_contains?: Maybe<String>
  updatedFields_contains_every?: Maybe<String[] | String>
  updatedFields_contains_some?: Maybe<String[] | String>
  node?: Maybe<ChatWhereInput>
  AND?: Maybe<ChatSubscriptionWhereInput[] | ChatSubscriptionWhereInput>
  OR?: Maybe<ChatSubscriptionWhereInput[] | ChatSubscriptionWhereInput>
  NOT?: Maybe<ChatSubscriptionWhereInput[] | ChatSubscriptionWhereInput>
}

export interface GroupChatSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>
  updatedFields_contains?: Maybe<String>
  updatedFields_contains_every?: Maybe<String[] | String>
  updatedFields_contains_some?: Maybe<String[] | String>
  node?: Maybe<GroupChatWhereInput>
  AND?: Maybe<
    GroupChatSubscriptionWhereInput[] | GroupChatSubscriptionWhereInput
  >
  OR?: Maybe<
    GroupChatSubscriptionWhereInput[] | GroupChatSubscriptionWhereInput
  >
  NOT?: Maybe<
    GroupChatSubscriptionWhereInput[] | GroupChatSubscriptionWhereInput
  >
}

export interface MessageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>
  updatedFields_contains?: Maybe<String>
  updatedFields_contains_every?: Maybe<String[] | String>
  updatedFields_contains_some?: Maybe<String[] | String>
  node?: Maybe<MessageWhereInput>
  AND?: Maybe<MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput>
  OR?: Maybe<MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput>
  NOT?: Maybe<MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput>
}

export interface PrivateChatSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>
  updatedFields_contains?: Maybe<String>
  updatedFields_contains_every?: Maybe<String[] | String>
  updatedFields_contains_some?: Maybe<String[] | String>
  node?: Maybe<PrivateChatWhereInput>
  AND?: Maybe<
    PrivateChatSubscriptionWhereInput[] | PrivateChatSubscriptionWhereInput
  >
  OR?: Maybe<
    PrivateChatSubscriptionWhereInput[] | PrivateChatSubscriptionWhereInput
  >
  NOT?: Maybe<
    PrivateChatSubscriptionWhereInput[] | PrivateChatSubscriptionWhereInput
  >
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>
  updatedFields_contains?: Maybe<String>
  updatedFields_contains_every?: Maybe<String[] | String>
  updatedFields_contains_some?: Maybe<String[] | String>
  node?: Maybe<UserWhereInput>
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>
}

export interface NodeNode {
  id: ID_Output
}

export interface Category {
  id: ID_Output
  name: String
}

export interface CategoryPromise extends Promise<Category>, Fragmentable {
  id: () => Promise<ID_Output>
  name: () => Promise<String>
}

export interface CategorySubscription
  extends Promise<AsyncIterator<Category>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  name: () => Promise<AsyncIterator<String>>
}

export interface CategoryNullablePromise
  extends Promise<Category | null>,
    Fragmentable {
  id: () => Promise<ID_Output>
  name: () => Promise<String>
}

export interface CategoryConnection {
  pageInfo: PageInfo
  edges: CategoryEdge[]
}

export interface CategoryConnectionPromise
  extends Promise<CategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<CategoryEdge>>() => T
  aggregate: <T = AggregateCategoryPromise>() => T
}

export interface CategoryConnectionSubscription
  extends Promise<AsyncIterator<CategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <T = Promise<AsyncIterator<CategoryEdgeSubscription>>>() => T
  aggregate: <T = AggregateCategorySubscription>() => T
}

export interface PageInfo {
  hasNextPage: Boolean
  hasPreviousPage: Boolean
  startCursor?: String
  endCursor?: String
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>
  hasPreviousPage: () => Promise<Boolean>
  startCursor: () => Promise<String>
  endCursor: () => Promise<String>
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>
  startCursor: () => Promise<AsyncIterator<String>>
  endCursor: () => Promise<AsyncIterator<String>>
}

export interface CategoryEdge {
  node: Category
  cursor: String
}

export interface CategoryEdgePromise
  extends Promise<CategoryEdge>,
    Fragmentable {
  node: <T = CategoryPromise>() => T
  cursor: () => Promise<String>
}

export interface CategoryEdgeSubscription
  extends Promise<AsyncIterator<CategoryEdge>>,
    Fragmentable {
  node: <T = CategorySubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateCategory {
  count: Int
}

export interface AggregateCategoryPromise
  extends Promise<AggregateCategory>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregateCategorySubscription
  extends Promise<AsyncIterator<AggregateCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface Chat {
  id: ID_Output
  type?: ChatType
}

export interface ChatPromise extends Promise<Chat>, Fragmentable {
  id: () => Promise<ID_Output>
  type: () => Promise<ChatType>
}

export interface ChatSubscription
  extends Promise<AsyncIterator<Chat>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  type: () => Promise<AsyncIterator<ChatType>>
}

export interface ChatNullablePromise
  extends Promise<Chat | null>,
    Fragmentable {
  id: () => Promise<ID_Output>
  type: () => Promise<ChatType>
}

export interface ChatConnection {
  pageInfo: PageInfo
  edges: ChatEdge[]
}

export interface ChatConnectionPromise
  extends Promise<ChatConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<ChatEdge>>() => T
  aggregate: <T = AggregateChatPromise>() => T
}

export interface ChatConnectionSubscription
  extends Promise<AsyncIterator<ChatConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <T = Promise<AsyncIterator<ChatEdgeSubscription>>>() => T
  aggregate: <T = AggregateChatSubscription>() => T
}

export interface ChatEdge {
  node: Chat
  cursor: String
}

export interface ChatEdgePromise extends Promise<ChatEdge>, Fragmentable {
  node: <T = ChatPromise>() => T
  cursor: () => Promise<String>
}

export interface ChatEdgeSubscription
  extends Promise<AsyncIterator<ChatEdge>>,
    Fragmentable {
  node: <T = ChatSubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateChat {
  count: Int
}

export interface AggregateChatPromise
  extends Promise<AggregateChat>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregateChatSubscription
  extends Promise<AsyncIterator<AggregateChat>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface GroupChat {
  id: ID_Output
  createdAt: DateTimeOutput
}

export interface GroupChatPromise extends Promise<GroupChat>, Fragmentable {
  id: () => Promise<ID_Output>
  category: <T = CategoryPromise>() => T
  participates: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput
    orderBy?: UserOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  messages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput
    orderBy?: MessageOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  createdAt: () => Promise<DateTimeOutput>
}

export interface GroupChatSubscription
  extends Promise<AsyncIterator<GroupChat>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  category: <T = CategorySubscription>() => T
  participates: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput
    orderBy?: UserOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  messages: <T = Promise<AsyncIterator<MessageSubscription>>>(args?: {
    where?: MessageWhereInput
    orderBy?: MessageOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>
}

export interface GroupChatNullablePromise
  extends Promise<GroupChat | null>,
    Fragmentable {
  id: () => Promise<ID_Output>
  category: <T = CategoryPromise>() => T
  participates: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput
    orderBy?: UserOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  messages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput
    orderBy?: MessageOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  createdAt: () => Promise<DateTimeOutput>
}

export interface User {
  id: ID_Output
  nickname: String
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>
  nickname: () => Promise<String>
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  nickname: () => Promise<AsyncIterator<String>>
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>
  nickname: () => Promise<String>
}

export interface Message {
  id: ID_Output
  content: String
  createdAt: DateTimeOutput
}

export interface MessagePromise extends Promise<Message>, Fragmentable {
  id: () => Promise<ID_Output>
  content: () => Promise<String>
  createdAt: () => Promise<DateTimeOutput>
  author: <T = UserPromise>() => T
  chat: <T = ChatPromise>() => T
}

export interface MessageSubscription
  extends Promise<AsyncIterator<Message>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  content: () => Promise<AsyncIterator<String>>
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>
  author: <T = UserSubscription>() => T
  chat: <T = ChatSubscription>() => T
}

export interface MessageNullablePromise
  extends Promise<Message | null>,
    Fragmentable {
  id: () => Promise<ID_Output>
  content: () => Promise<String>
  createdAt: () => Promise<DateTimeOutput>
  author: <T = UserPromise>() => T
  chat: <T = ChatPromise>() => T
}

export interface GroupChatConnection {
  pageInfo: PageInfo
  edges: GroupChatEdge[]
}

export interface GroupChatConnectionPromise
  extends Promise<GroupChatConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<GroupChatEdge>>() => T
  aggregate: <T = AggregateGroupChatPromise>() => T
}

export interface GroupChatConnectionSubscription
  extends Promise<AsyncIterator<GroupChatConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <T = Promise<AsyncIterator<GroupChatEdgeSubscription>>>() => T
  aggregate: <T = AggregateGroupChatSubscription>() => T
}

export interface GroupChatEdge {
  node: GroupChat
  cursor: String
}

export interface GroupChatEdgePromise
  extends Promise<GroupChatEdge>,
    Fragmentable {
  node: <T = GroupChatPromise>() => T
  cursor: () => Promise<String>
}

export interface GroupChatEdgeSubscription
  extends Promise<AsyncIterator<GroupChatEdge>>,
    Fragmentable {
  node: <T = GroupChatSubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateGroupChat {
  count: Int
}

export interface AggregateGroupChatPromise
  extends Promise<AggregateGroupChat>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregateGroupChatSubscription
  extends Promise<AsyncIterator<AggregateGroupChat>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface MessageConnection {
  pageInfo: PageInfo
  edges: MessageEdge[]
}

export interface MessageConnectionPromise
  extends Promise<MessageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<MessageEdge>>() => T
  aggregate: <T = AggregateMessagePromise>() => T
}

export interface MessageConnectionSubscription
  extends Promise<AsyncIterator<MessageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <T = Promise<AsyncIterator<MessageEdgeSubscription>>>() => T
  aggregate: <T = AggregateMessageSubscription>() => T
}

export interface MessageEdge {
  node: Message
  cursor: String
}

export interface MessageEdgePromise extends Promise<MessageEdge>, Fragmentable {
  node: <T = MessagePromise>() => T
  cursor: () => Promise<String>
}

export interface MessageEdgeSubscription
  extends Promise<AsyncIterator<MessageEdge>>,
    Fragmentable {
  node: <T = MessageSubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateMessage {
  count: Int
}

export interface AggregateMessagePromise
  extends Promise<AggregateMessage>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregateMessageSubscription
  extends Promise<AsyncIterator<AggregateMessage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface PrivateChat {
  id: ID_Output
  createdAt: DateTimeOutput
}

export interface PrivateChatPromise extends Promise<PrivateChat>, Fragmentable {
  id: () => Promise<ID_Output>
  participateA: <T = UserPromise>() => T
  participateB: <T = UserPromise>() => T
  messages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput
    orderBy?: MessageOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  createdAt: () => Promise<DateTimeOutput>
}

export interface PrivateChatSubscription
  extends Promise<AsyncIterator<PrivateChat>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  participateA: <T = UserSubscription>() => T
  participateB: <T = UserSubscription>() => T
  messages: <T = Promise<AsyncIterator<MessageSubscription>>>(args?: {
    where?: MessageWhereInput
    orderBy?: MessageOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>
}

export interface PrivateChatNullablePromise
  extends Promise<PrivateChat | null>,
    Fragmentable {
  id: () => Promise<ID_Output>
  participateA: <T = UserPromise>() => T
  participateB: <T = UserPromise>() => T
  messages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput
    orderBy?: MessageOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  createdAt: () => Promise<DateTimeOutput>
}

export interface PrivateChatConnection {
  pageInfo: PageInfo
  edges: PrivateChatEdge[]
}

export interface PrivateChatConnectionPromise
  extends Promise<PrivateChatConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<PrivateChatEdge>>() => T
  aggregate: <T = AggregatePrivateChatPromise>() => T
}

export interface PrivateChatConnectionSubscription
  extends Promise<AsyncIterator<PrivateChatConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <T = Promise<AsyncIterator<PrivateChatEdgeSubscription>>>() => T
  aggregate: <T = AggregatePrivateChatSubscription>() => T
}

export interface PrivateChatEdge {
  node: PrivateChat
  cursor: String
}

export interface PrivateChatEdgePromise
  extends Promise<PrivateChatEdge>,
    Fragmentable {
  node: <T = PrivateChatPromise>() => T
  cursor: () => Promise<String>
}

export interface PrivateChatEdgeSubscription
  extends Promise<AsyncIterator<PrivateChatEdge>>,
    Fragmentable {
  node: <T = PrivateChatSubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregatePrivateChat {
  count: Int
}

export interface AggregatePrivateChatPromise
  extends Promise<AggregatePrivateChat>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregatePrivateChatSubscription
  extends Promise<AsyncIterator<AggregatePrivateChat>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface UserConnection {
  pageInfo: PageInfo
  edges: UserEdge[]
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<UserEdge>>() => T
  aggregate: <T = AggregateUserPromise>() => T
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T
  aggregate: <T = AggregateUserSubscription>() => T
}

export interface UserEdge {
  node: User
  cursor: String
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T
  cursor: () => Promise<String>
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateUser {
  count: Int
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface BatchPayload {
  count: Long
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>
}

export interface CategorySubscriptionPayload {
  mutation: MutationType
  node: Category
  updatedFields: String[]
  previousValues: CategoryPreviousValues
}

export interface CategorySubscriptionPayloadPromise
  extends Promise<CategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = CategoryPromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = CategoryPreviousValuesPromise>() => T
}

export interface CategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = CategorySubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = CategoryPreviousValuesSubscription>() => T
}

export interface CategoryPreviousValues {
  id: ID_Output
  name: String
}

export interface CategoryPreviousValuesPromise
  extends Promise<CategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>
  name: () => Promise<String>
}

export interface CategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<CategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  name: () => Promise<AsyncIterator<String>>
}

export interface ChatSubscriptionPayload {
  mutation: MutationType
  node: Chat
  updatedFields: String[]
  previousValues: ChatPreviousValues
}

export interface ChatSubscriptionPayloadPromise
  extends Promise<ChatSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = ChatPromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = ChatPreviousValuesPromise>() => T
}

export interface ChatSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ChatSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = ChatSubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = ChatPreviousValuesSubscription>() => T
}

export interface ChatPreviousValues {
  id: ID_Output
  type?: ChatType
}

export interface ChatPreviousValuesPromise
  extends Promise<ChatPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>
  type: () => Promise<ChatType>
}

export interface ChatPreviousValuesSubscription
  extends Promise<AsyncIterator<ChatPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  type: () => Promise<AsyncIterator<ChatType>>
}

export interface GroupChatSubscriptionPayload {
  mutation: MutationType
  node: GroupChat
  updatedFields: String[]
  previousValues: GroupChatPreviousValues
}

export interface GroupChatSubscriptionPayloadPromise
  extends Promise<GroupChatSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = GroupChatPromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = GroupChatPreviousValuesPromise>() => T
}

export interface GroupChatSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GroupChatSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = GroupChatSubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = GroupChatPreviousValuesSubscription>() => T
}

export interface GroupChatPreviousValues {
  id: ID_Output
  createdAt: DateTimeOutput
}

export interface GroupChatPreviousValuesPromise
  extends Promise<GroupChatPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>
  createdAt: () => Promise<DateTimeOutput>
}

export interface GroupChatPreviousValuesSubscription
  extends Promise<AsyncIterator<GroupChatPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>
}

export interface MessageSubscriptionPayload {
  mutation: MutationType
  node: Message
  updatedFields: String[]
  previousValues: MessagePreviousValues
}

export interface MessageSubscriptionPayloadPromise
  extends Promise<MessageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = MessagePromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = MessagePreviousValuesPromise>() => T
}

export interface MessageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MessageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = MessageSubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = MessagePreviousValuesSubscription>() => T
}

export interface MessagePreviousValues {
  id: ID_Output
  content: String
  createdAt: DateTimeOutput
}

export interface MessagePreviousValuesPromise
  extends Promise<MessagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>
  content: () => Promise<String>
  createdAt: () => Promise<DateTimeOutput>
}

export interface MessagePreviousValuesSubscription
  extends Promise<AsyncIterator<MessagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  content: () => Promise<AsyncIterator<String>>
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>
}

export interface PrivateChatSubscriptionPayload {
  mutation: MutationType
  node: PrivateChat
  updatedFields: String[]
  previousValues: PrivateChatPreviousValues
}

export interface PrivateChatSubscriptionPayloadPromise
  extends Promise<PrivateChatSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = PrivateChatPromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = PrivateChatPreviousValuesPromise>() => T
}

export interface PrivateChatSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PrivateChatSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = PrivateChatSubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = PrivateChatPreviousValuesSubscription>() => T
}

export interface PrivateChatPreviousValues {
  id: ID_Output
  createdAt: DateTimeOutput
}

export interface PrivateChatPreviousValuesPromise
  extends Promise<PrivateChatPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>
  createdAt: () => Promise<DateTimeOutput>
}

export interface PrivateChatPreviousValuesSubscription
  extends Promise<AsyncIterator<PrivateChatPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>
}

export interface UserSubscriptionPayload {
  mutation: MutationType
  node: User
  updatedFields: String[]
  previousValues: UserPreviousValues
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = UserPromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = UserPreviousValuesPromise>() => T
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = UserSubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = UserPreviousValuesSubscription>() => T
}

export interface UserPreviousValues {
  id: ID_Output
  nickname: String
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>
  nickname: () => Promise<String>
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  nickname: () => Promise<AsyncIterator<String>>
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number
export type ID_Output = string

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string

export type Long = string

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: 'User',
    embedded: false
  },
  {
    name: 'Message',
    embedded: false
  },
  {
    name: 'Category',
    embedded: false
  },
  {
    name: 'ChatType',
    embedded: false
  },
  {
    name: 'Chat',
    embedded: false
  },
  {
    name: 'PrivateChat',
    embedded: false
  },
  {
    name: 'GroupChat',
    embedded: false
  }
]

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env['PRISMA_URL']}`
})
export const prisma = new Prisma()
